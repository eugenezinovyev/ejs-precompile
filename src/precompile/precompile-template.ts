import { compile } from 'ejs';
import { relative } from 'node:path';
import { format } from 'prettier';
import * as tsImport from 'typescript';

/* c8 ignore next */
const ts: typeof tsImport = (tsImport as any).default ?? tsImport;

export type EjsCompileOptions = Parameters<typeof compile>[1];

export type PrecompileOptions = {
    /**
     * Output language. This is used to determine the extension of the output file.
     * @default 'javascript'
     */
    language?: 'javascript' | 'typescript' | undefined;
};

export type PrecompileTemplateOptions = {
    /**
     * Path to the input file. Optional, works together with `outputPath`.
     */
    inputPath?: string | undefined;

    /**
     * Path to the output file. Optional, works together with `inputPath`.
     */
    outputPath?: string | undefined;

    /**
     * EJS template content.
     */
    inputContent: string;

    /**
     * EJS compile options.
     */
    compileOptions: EjsCompileOptions;

    /**
     * Default values for template variables.
     */
    defaults?: Record<string, unknown>;

    /**
     * Precompile options.
     */
    options?: PrecompileOptions;
};

export type PrecompiledTemplate = {
    /**
     * EJS template content.
     */
    inputContent: string;

    /**
     * Generated JavaScript module content.
     */
    outputContent: string;

    /**
     * Compiled template function.
     */
    templateFunction: ReturnType<typeof compile>;
};

/**
 * Pre-compiles EJS template into JavaScript module.
 * When `inputPath` and `outputPath` are provided, the generated module will include a comment with relative path to the source file.
 * @param options Precompile options.
 * @returns Precompiled template.
 */
export default async function precompileTemplate(options: PrecompileTemplateOptions): Promise<PrecompiledTemplate> {
    const { inputContent, compileOptions } = options;
    const templateFunction = compile(inputContent, compileOptions);

    return {
        inputContent,
        outputContent: await prepareTemplateModule(templateFunction, options),
        templateFunction,
    };
}

async function prepareTemplateModule(templateFunction: ReturnType<typeof compile>, options: PrecompileTemplateOptions): Promise<string> {
    const defaults = options.defaults ?? {};
    const templateModuleTs = `\
//@ts-nocheck
/* eslint-disable */
import { Data, EscapeCallback, IncludeCallback, RethrowCallback } from 'ejs';

${autogeneratedHeader(options)}

"use strict";

function deepMerge(target: Data, source: Data): Data {
    for (const key of Object.keys(source)) {
        const targetValue = target[key];
        const sourceValue = source[key];

        if (Array.isArray(targetValue) && Array.isArray(sourceValue)) {
            target[key] = targetValue.concat(sourceValue);
        } else if (typeof targetValue === 'object' && typeof sourceValue === 'object') {
            target[key] = deepMerge(targetValue as Data, sourceValue as Data);
        } else {
            target[key] = sourceValue;
        }
    }

    return target;
}

export default function render(locals?: Data, escapeFn?: EscapeCallback, include?: IncludeCallback, rethrow?: RethrowCallback): string {
    const defaults = ${JSON.stringify(defaults)};
    const localsWithDefaults = deepMerge(Object.assign({}, defaults), locals ?? {});

    return (${templateFunction.toString()})(localsWithDefaults, escapeFn, include, rethrow);
}
`;

    if (options.options?.language === 'typescript') {
        return await format(templateModuleTs, { parser: 'typescript' });
    } else {
        const templateModuleJs = ts.transpileModule(templateModuleTs, {
            compilerOptions: {
                module: ts.ModuleKind.NodeNext,
                target: ts.ScriptTarget.ESNext,
            },
        });

        return await format(templateModuleJs.outputText, { parser: 'babel' });
    }
}

function autogeneratedHeader({ inputPath, outputPath }: PrecompileTemplateOptions): string {
    const includePathToSource = !!inputPath && !!outputPath;
    const maybePathToSource: string = includePathToSource ? ` ${relative(outputPath, inputPath)}` : '';

    return `\
/**
* THIS FILE HAS BEEN AUTO-GENERATED, DO NOT EDIT!
* Instead, edit the source EJS template file${maybePathToSource}.
*/`;
}
